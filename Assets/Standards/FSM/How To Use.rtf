{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf100
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 1. Create an abstract non-generic class extending generic class State (e.g. StateExampleBase.cs)\
\
2. Create all your classes extending your non-generic class created on step 1 (e.g. StateExampleIdle.cs and StateExampleRun.cs)\
\
3. Generate a ScriptableObject for each State. Select your state scripts and select Overtime > Finite State Machine > Create New States From Selection. It works with multi-selection.\
\
4. Create a core class for your object that will be controlled by FSM (e.g. FSMExample). On Start, create a new StateMachine instance passing this class, an array with ScriptableObject states and initial state enum as parameters. Optionally, pass boolean debug and track states as well.\
\
5. On Update and Fixed Update, call Update and FixedUpdate methods from your created StateMachine.\
\
(optional) 6. If you want you can call OnTrigger and OnCollision methods on StateMachine as well.\
\
General Usage Info:\
\
- State machine works with transitions and internally changing to states.\
- States Enter() and Exit() methods will be called whenever StateMachine enters/exit that state\
- States AddTransition() method will be called once when StateMachine is created.}